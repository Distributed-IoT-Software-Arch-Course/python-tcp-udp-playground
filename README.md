# Python TCP & UDP Protocols Playground

This project contains a group of Python examples focusing on the following aspects:

- JSON Serialization and Deserialization
- UDP demo clients and servers
- TCP demo client and servers

Main sections of this project and playground are:

- [JSON Introduction](#json-introduction)
- [UDP Client & Server](#udp-client--server)
- [TCP Client & Server](#tcp-client--server)
- [UDP & TCP to call IoT Service](#udp--tcp-to-call-iot-service)
- [Json TCP Client & Server](#json-tcp-client--server)

## Json Introduction

JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. 
It is a text format that is completely language-independent, making it ideal for data exchange between different systems.

An example of a JSON Datastructure is:

```json
{
  "name": "John Doe",
  "age": 30,
  "city": "New York"
}
```

### Basic components of JSON

Objects:
- Enclosed in curly braces ({}).
- Contain key-value pairs separated by commas.
- Keys are strings (enclosed in double quotes).
- Values can be any valid JSON data type (including objects, arrays, strings, numbers, booleans, or null).

Arrays:
- Enclosed in square brackets ([]).
- Contain ordered lists of values separated by commas.
- Values can be any valid JSON data type.

Data types in JSON:

- Strings: Enclosed in double quotes (").
- Numbers: Can be integers or floating-point numbers.
- Booleans: true or false.
- Null: Represents the absence of a value.

Characteristics of JSON:

- Human-readable: JSON is designed to be easily read and understood by humans.
- Machine-readable: JSON is easily parsed and generated by machines.
- Lightweight: JSON is a relatively small format compared to XML.
- Language-independent: JSON is not tied to any specific programming language.
- Hierarchical: JSON data is organized in a hierarchical structure using objects and arrays.

Example of a basic JSON structure:

```json
{
  "name": "John Doe",
  "age": 30,
  "city": "New York",
  "isStudent": false,
  "hobbies": ["reading", "coding", "traveling"]
}
```

### Import Json Package

Python provides built-in support for JSON through the json module. Here's a brief overview of how to use it:

```python
import json
```

### Load JSON data from a file

This will load the JSON data from the data.json file and store it in the data variable as a Python object (e.g., dictionary, list, or a combination of both).

```python
with open('data.json', 'r') as f:
    data = json.load(f)
```

### Dump data to a JSON file

This will write the Python object data as JSON data to the output.json file.

```python
with open('output.json', 'w') as f:
    json.dump(data, f)
```

### Json & Dictionary

From Dictionary to Json String

```python
data = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

json_data = json.dumps(data)
print(json_data)
```

The output will be:

```json
{"name": "Alice", "age": 30, "city": "New York"}
```

From Json String to Dictionary

```python
json_string = '{"name": "Bob", "age": 25, "city": "Los Angeles"}'
python_dict = json.loads(json_string)

print(python_dict["name"])   # Output: Bob
print(python_dict["age"])    # Output: 25
print(python_dict["city"])   # Output: Los Angeles
```

## UDP Client & Server

Files Provided
- udp_client.py: The UDP client script.
- udp_server.py: The UDP server script.

The UDP client-server example demonstrates how to create a simple UDP client and server using Python. 
The client sends a message to the server, and the server echoes the message back to the client.

The server code listens for incoming UDP packets on a specified IP address and port. 
When a packet is received, the server extracts the message and the client's address and sends the message back to the client.

```python
import socket

# Define the IP address and port to listen on
UDP_IP = "127.0.0.1"
UDP_PORT = 5005

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Bind the socket to the address and port
sock.bind((UDP_IP, UDP_PORT))

print(f"Listening on {UDP_IP}:{UDP_PORT}")

# Infinite loop to listen for incoming UDP packets
while True:
    # Receive data from the client (1024 bytes is the buffer size)
    data, addr = sock.recvfrom(1024)
    print(f"Received message: {data} from {addr}")

    # Echo the received data back to the client
    sock.sendto(data, addr)
```

On the other hand, the client code sends a message to the server and waits for a response. 
When the client receives a response from the server, it prints the message.

```python
import socket

# Define the server IP address and port to send data to
UDP_IP = "127.0.0.1"
UDP_PORT = 5005

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Define the message to send
MESSAGE = b"Hello, Server!"

print(f"Sending message to {UDP_IP}:{UDP_PORT}")

# Send the message to the server
sock.sendto(MESSAGE, (UDP_IP, UDP_PORT))

# Receive response from the server
data, server = sock.recvfrom(1024)
print(f"Received message from server: {data}")
```

You have successfully set up and run a simple UDP client-server application using Python. 
This example demonstrates the basics of sending and receiving UDP packets between a client and server. 
You can extend this example to build more complex applications as needed.

## TCP Client & Server

Files Provided
- tcp_client.py: The TCP client script.
- tcp_server.py: The TCP server script.

The TCP client-server example demonstrates how to create a simple TCP client and server using Python.
The client establishes a connection to the server, sends a message, and receives a response from the server.

The server code listens for incoming TCP connections on a specified IP address and port. 
When a client connects, the server receives the message, processes it, and sends a response back to the client.

```python
import socket

HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = 65432        # Port to listen on (non-privileged ports are > 1023)

# Create a TCP/IP socket associated with the address family IPv4 and the socket type SOCK_STREAM
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

    # Bind the socket to the address and port
    s.bind((HOST, PORT))

    # Enable the server to accept connections
    s.listen()

    # Print a message to indicate that the server is waiting for incoming client connections
    print("Waiting for incoming client connections ...")

    # Accept a connection from a client
    conn, addr = s.accept()

    # With the connection established communicate with the client
    with conn:
        print('Connected by', addr)
        while True:
            # Receive data from the client using a buffer of 1024 bytes
            data = conn.recv(1024)
            print("Received Message: {}".format(data))
            if not data:
                break
            # Send the received data back to the client (acting as an echo server)
            conn.sendall(data)
```

On the other hand, the client code establishes a connection to the server, sends a message, and receives a response from the server.

```python
import socket

HOST = '127.0.0.1'  # The server's hostname or IP address
PORT = 65432        # The port used by the server

# Create a TCP/IP socket associated with the address family IPv4 and the socket type SOCK_STREAM
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    
    # Connect to the server using the specified address and port
    s.connect((HOST, PORT))
    
    # Send a message to the server a buffer of 1024 bytes starting with the string "Hello, world"
    s.sendall(b'Hello, world')
    
    # Receive data from the server using a buffer of 1024 bytes
    data = s.recv(1024)
    
    # Close the connection
    s.close()
    
    # Print the received data
    print('Received', repr(data))
```

You have successfully set up and run a simple TCP client-server application using Python.

## UDP & TCP to call IoT Service

We can extend the previous examples to create a simple IoT service that can be called using UDP or TCP protocols.
In the following sub-sections you find the main changes of both client and server scripts to call the IoT service.
The main differences is that the client send a "structured" messages like: 

```text
request=create_device;device_id=1;device_description=TestDevice
```

The server will parse the message and return a response like:

```text
response=OK;msg=device_created
```

**Note:** This messages have to be parsed and validated in the server and client side. They are not the best 
way to send data and invoke services, we will learn how to use JSON messages in the next section and in next lectures
how to use better IoT protocols for interactions with both IoT devices and services.

### UDP IoT Service

The updated server is:

```python
import socket

localIP = "127.0.0.1"
localPort = 20001
bufferSize = 1024
msgFromServer = "response=OK;msg=device_created"
bytesToSend = str.encode(msgFromServer)

# Create a datagram socket
UDPServerSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)

# Bind to address and ip
UDPServerSocket.bind((localIP, localPort))

print("UDP server up and listening")

# Listen for incoming datagrams
while (True):
    bytesAddressPair = UDPServerSocket.recvfrom(bufferSize)
    message = bytesAddressPair[0]
    address = bytesAddressPair[1]

    clientMsg = "Message from Client:{}".format(message)
    clientIP = "Client IP Address:{}".format(address)

    str_message = message.decode("utf-8")
    request_array = str_message.split(";")

    for element in request_array:

        element_array = element.split("=")
        key = element_array[0]
        value = element_array[1]

        print(f'Received Key: {key} Value: {value}')

    print(clientMsg)
    print(clientIP)

    # Sending a reply to client
    UDPServerSocket.sendto(bytesToSend, address)
```

The updated client is:

```python
import socket

msgFromClient = "request=create_device;device_id=1;device_description=TestDevice"
bytesToSend = str.encode(msgFromClient)
serverAddressPort = ("127.0.0.1", 20001)
bufferSize = 1024

# Create a UDP socket at client side
UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)

# Send to server using created UDP socket
UDPClientSocket.sendto(bytesToSend, serverAddressPort)
msgFromServer = UDPClientSocket.recvfrom(bufferSize)

msg = "Message from Server {}".format(msgFromServer[0])

str_message = msgFromServer[0].decode("utf-8")
request_array = str_message.split(";")

for element in request_array:

    element_array = element.split("=")
    key = element_array[0]
    value = element_array[1]

    print(f'Received Key: {key} Value: {value}')
```

### TCP IoT Service

The updated server is:

```python
import socket

HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = 65432        # Port to listen on (non-privileged ports are > 1023)

# Create a TCP/IP socket associated with the address family IPv4 and the socket type SOCK_STREAM
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

    # Bind the socket to the address and port
    s.bind((HOST, PORT))

    # Enable the server to accept connections
    s.listen()

    # Print a message to indicate that the server is waiting for incoming client connections
    print("Waiting for incoming client connections ...")

    # Accept a connection from a client
    conn, addr = s.accept()

    # With the connection established communicate with the client
    with conn:
        print('Connected by', addr)
        while True:
            # Receive data from the client using a buffer of 1024 bytes
            data = conn.recv(1024)
            print("Received Message: {}".format(data))

            # If no data is received, break the loop
            if not data:
                break

            str_message = data.decode("utf-8")
            request_array = str_message.split(";")

            for element in request_array:
                element_array = element.split("=")
                key = element_array[0]
                value = element_array[1]

                print(f'Received Key: {key} Value: {value}')

            # Send the received data back to the client (acting as an echo server)
            conn.sendall(b"response=OK;msg=device_created")
```

The updated client is:

```python
import socket

HOST = '127.0.0.1'  # The server's hostname or IP address
PORT = 65432        # The port used by the server

# Create a TCP/IP socket associated with the address family IPv4 and the socket type SOCK_STREAM
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

    # Connect to the server using the specified address and port
    s.connect((HOST, PORT))

    # Send a message to the server a buffer of 1024 bytes starting with the string "Hello, world"
    s.sendall(b'request=create_device;device_id=1;device_description=TestDevice')

    # Receive data from the server using a buffer of 1024 bytes
    data = s.recv(1024)

    # Close the connection
    s.close()

    # Print the received data
    print('Received', repr(data))

    str_message = data.decode("utf-8")
    request_array = str_message.split(";")

    for element in request_array:
        element_array = element.split("=")
        key = element_array[0]
        value = element_array[1]

        print(f'Received Key: {key} Value: {value}')
```

## Json TCP Client & Server

In this example we will create a simple TCP client and server that communicate using JSON messages.
The server exposes the possibility to create a reference to a new IoT device.

Files Provided:
- json_tcp_client.py: The JSON TCP client script
- json_tcp_server.py: The JSON TCP server script
- iot_device.py: The IoT device description
- service_message.py: The service message description

First we will define the IoT device class and the service message class.

```python
import json

class IoTDevice:
    """ IoT Device Class describing the device properties """

    def __init__(self, device_id, manufacturer, software_version, latitude, longitude):
        """ Initialize the IoT Device with the provided properties """

        self.device_id = device_id
        self.manufacturer = manufacturer
        self.software_version = software_version
        self.latitude = latitude
        self.longitude = longitude

    def __str__(self):
        """ Return a string representation of the IoT Device """
        return f"DeviceId: {self.device_id} - Manufacturer: {self.manufacturer} - Software Version: {self.software_version} - Lat/Lng: {self.latitude}/{self.longitude}"

    def to_json(self):
        """ Serialize the IoT Device to a JSON string """
        return json.dumps(self, default=lambda o: o.__dict__)
```

This class represents an IoT device with the following properties device_id, manufacturer, software_version, latitude, and longitude
with the aim to describe it in the interaction between the client and the server for example associated to the 
creation of a new device.

In order to describe a service request and message for the server we will define the following class.

```python
import json

class ServiceMessage:
    """ Service Message Class describing the action command and the target IoT Device
    For example this class can be used to describe a CREATED DEVICE request on the server """

    def __init__(self, action_command, iot_device):
        """ Initialize the Service Message with the provided action command and IoT Device """
        self.action_command = action_command
        self.iot_device = iot_device

    def __str__(self):
        """ Return a string representation of the Service Message """
        return f"Action Command: {self.action_command} - Target IoT Device: {self.iot_device}"

    def to_json(self):
        """ Serialize the Service Message to a JSON string """
        return json.dumps(self, default=lambda o: o.__dict__)
```

In this class, we define a service message that contains an action command and an IoT device a target for the action command.
For example, this class can be used to describe a CREATED DEVICE request on the server.

Now we will define the server code that listens for incoming TCP connections on a specified IP address and port.
When a client connects, the server receives a JSON message, processes it, and sends a response back to the client.

```python
import socket
import json
from json import JSONDecodeError
from service_message import ServiceMessage

HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = 65432        # Port to listen on (non-privileged ports are > 1023)

# Create a TCP/IP socket associated with the address family IPv4 and the socket type SOCK_STREAM
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

    # Bind the socket to the address and port
    s.bind((HOST, PORT))

    # Enable the server to accept connections
    s.listen()

    # Accept a connection from a client
    conn, addr = s.accept()
    
    # With the connection established communicate with the client
    with conn:
        while True:
            # Receive data from the client using a buffer of 1024 bytes
            data = conn.recv(1024)

            # Decode the received data to a string using the decode method
            receivedString = data.decode('UTF-8')

            # Check if the received data is not empty
            if len(data) > 0:
                try:
                    # Parse the received JSON string to a Python dictionary using the json.loads method
                    serviceMessage = ServiceMessage(**json.loads(receivedString))
                   
                    # Send an OK response to the client
                    conn.sendall(str.encode("OK"))
                except JSONDecodeError:
                    # Send a KO response to the client
                    conn.sendall(str.encode("KO"))
            if not data:
                # Break the loop if no data is received and send a KO response to the client
                conn.sendall(str.encode("KO"))
                break
```

On the other hand, the client code establishes a connection to the server, sends a JSON message
describing the service request and the associated IoT Device, and receives a response from the server.

```python
import socket
from iot_device import IoTDevice
from service_message import ServiceMessage

HOST = '127.0.0.1'  # The server's hostname or IP address
PORT = 65432        # The port used by the server

# Create a new IoT Device instance
iotDevice = IoTDevice("device-0001", "acme-inc", "v0.0.1-beta", 44.101010, 10.421321)
print(iotDevice)

# Create a new Service Message instance to create the IoT Device on the server
serviceMessage = ServiceMessage("CREATE-DEVICE", iotDevice)

# Serialize the Service Message to a JSON string using the to_json method on the Service Message instance
msgFromClient = serviceMessage.to_json()
print(msgFromClient)

# Encode the JSON string to bytes using the str.encode method
bytesToSend = str.encode(msgFromClient)

# Create a TCP/IP socket associated with the address family IPv4 and the socket type SOCK_STREAM
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    # Connect to the server using the specified address and port
    s.connect((HOST, PORT))

    # Send the bytes to the server to create the IoT Device
    s.sendall(bytesToSend)

    # Receive response data from the server using a buffer of 1024 bytes
    data = s.recv(1024)

    # Close the connection
    s.close()

    # Print the received data
    print('Received', repr(data))
```

The client code establishes a connection to the server, sends a JSON message describing the service request and the associated IoT Device,
and receives a response from the server that can be OK or KO depending on the JSON message received.